
how to make mawk under MsDOS
---------------------------

Read the DOS section in the manual first.

In addition to a C compiler, you will need an
assembler and a yacc compatable parser generator.

Assuming you keep the same directory structure:

1)  run  mklib.bat in this directory to create msdos.lib

2)  move the makefile and mawk.dep  to ..
    ( The supplied dos makefile is for Borland's make.  I used to
      make mawk with MS make -- which make you use is no big deal.)

3)  If you want a Unix style command line for mawk, you'll need to
    write a function called reargv(int *, char ***) which passes
    mawk the modified argc and argv.  Compile and add to
    msdos.lib.

    The supplied reargv.c works with POLYSHELL by Polytron; for a
    different shell you could use it as an example.

    If this made sense and all went well, go to machine.h
    and
      #define  HAVE_REARGV   1

    If ! (sense || well ) , don't worry HAVE_REARGV is 0 by
    default.

4)  YACC --
On the PC I use bison.1.14, it works fine and is easy to find.
Surely easier to get than mawk.  Unfortunately I cannot distribute
the generated parse.c file.

    If you use bison, I suggest #if 0  in parse.c
    on the part that grows the parser stack.
    Then you won't need alloca().
    ( For mawk programs if the parser stack needs to grow, something
      is fatally wrong.)
    Also unless you are debugging the grammar, you don't need
    the tables yyrhs[] or yyprhs[] -- cut them out and save some data
    space.

You can make parse.c under unix with bison or another yacc and
move it to dos.

5)  The rand48.asm is hardwired for small model.  I've never made
a large model mawk, but as far as I can tell I think the only problem
is in rand48.asm.  The stack machine instructions (INST) assume a
pointer is a pointer is a pointer, so if you change to far data
pointers you'll also need to change to far code pointers.

Rand48 is overkill, you could use another random number generator
although the one supplied with your compiler is a near 
certainty to be poor.

On small model, you have about 40K of free data space which is plenty
except for programs that hold a medium or larger data file entirely
in memory.

==================================================================

The reason system() and pipes are missing is I haven't decided
entirely how to handle the runaway loop problem.  Dos makes
asynchronous termination of a program difficult, because DOS
itself might not be able to handle exit().

Hooking int 0x1a forces me to deal with cleanup and makes ^C
a pain.  What is the effect of my 0x1a on children? (That's why
no system() or pipes yet).  What do I have to check after a child
terminates, children can muck up the state of the parent process.


I have used mawk as is on DOS for about 6 months, what's missing
I rarely use  except to emit error messages and I use
errmsg() for that.  If I stall about fixing this stuff, DOS
might go away and I'll never have to deal with it.
